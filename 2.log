# [Git使用教程](https://github.com/DickyQie/Tool-use/tree/git-learning-document)

[Git教程](https://github.com/DickyQie/Tool-use/tree/git-learning-document)

![Gitå½ä"¤.jpg](https://raw.githubusercontent.com/loveagri/note/master/ud-img/Git命令.jpg)



![img](https://raw.githubusercontent.com/loveagri/note/master/ud-img/git-ml.png)



![img](https://raw.githubusercontent.com/loveagri/note/master/ud-img/git常用命令图解-1548298475565.png) 888
 888
<center><h1>git 放弃本地修改</h1></center>

[https://www.cnblogs.com/qufanblog/p/7606105.html](https://www.cnblogs.com/qufanblog/p/7606105.html)



## 一，未使用 git add 缓存代码时。

可以使用 git checkout -- filepathname (比如： git checkout -- readme.md  ，不要忘记中间的 “--” ，不写就成了检出分支了！！)。放弃所有的文件修改可以使用 git checkout .  命令。

此命令用来放弃掉所有还没有加入到缓存区（就是 git add 命令）的修改：内容修改与整个文件删除。但是此命令不会删除掉刚新建的文件。因为刚新建的文件还没已有加入到 git 的管理系统中。所以对于git是未知的。自己手动删除就好了。



## 二，已经使用了  git add 缓存了代码。

可以使用  git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所以的缓存可以使用 git reset HEAD . 命令。

此命令用来清除 git  对于文件修改的缓存。相当于撤销 git add 命令所在的工作。在使用本命令后，本地的修改并不会消失，而是回到了如（一）所示的状态。继续用（一）中的操作，就可以放弃本地的修改。



## 三，已经用 git commit  提交了代码。

可以使用 git reset --hard HEAD^ 来回退到上一次commit的状态。此命令可以用来回退到任意版本：git reset --hard  *commitId*

 888
```
git config --global user.name "nino"
git config --global user.email "nino@iv66.net"

Create a new repository
git clone http://10.66.72.115/newplatform/auto_package.git
cd auto_package
touch README.md
git add README.md
git commit -m "add README"
git push -u origin master

Existing folder
cd existing_folder
git init
git remote add origin http://10.66.72.115/newplatform/auto_package.git
git add .
git commit -m "Initial commit"
git push -u origin master

Existing Git repository
cd existing_repo
git remote rename origin old-origin
git remote add origin http://10.66.72.115/newplatform/auto_package.git
git push -u origin --all
git push -u origin --tags
```
 888
# Ssh-keygen生成过程

**1：生成RSA key 过程**
（1）在指定的用户目录下，右键打开git bash 执行 命名：`ssh-agent bash`
（2）生成RSA密钥，执行命令：`ssh-keygen -t rsa -C 742981086@qq.com`

![这里写图片描述](/Users/intech/Note/images/20161120145047649.png)



![image-20190121150726433](/Users/intech/Note/images/image-20190121150726433.png)



（3）添加密钥到ssh，执行的命令：`ssh-add` 888
# web和webApp如何实现上拉加载和下拉刷新

[链接](https://blog.csdn.net/kerryqpw/article/details/78169431)

实现思路：

1.后端提供分页接口

2.list页面打开默认显示第一页的列表

3.js监听到页面顶部下拉时，清除所有list显示，请求第一页列表显示

4.js监听到页面滚动到底部时，增量加载下一的列表进行列表显示

## 核心代码

```js
 $(document).scroll(function(){
		var bheight = $(document).height();//获取窗口高度
		var sheight = $("body")[0].scrollHeight;//获取滚动条高度，[0]是为了把jq对象转化为js对象
		var stop = getScrollTop();//滚动条距离顶部的距离
				
		console.log("bheight:"+bheight);
		console.log("sheight:"+sheight);
		console.log("stop:"+stop);
	console.log("document.body.scrollTop:"+document.body.scrollTop)
	console.log("window.screen.height:"+window.screen.height)
				

		if(stop==0){
//			alert("下拉刷新");
		}
		//滚动框到底部时加载更多
		if(stop-60>=sheight-window.screen.height){//当滚动条到顶部的距离等于滚动条高度减去窗口高度时
			//alert("加载更多");
			//加载更多新闻
			loadMoreNewList();
		}
	});
},
            

//获取滚动框到顶部的高度
function getScrollTop(){    
    var scrollTop=0;    
    if(document.documentElement&&document.documentElement.scrollTop){ 
            scrollTop=document.documentElement.scrollTop;    
    }else if(document.body){    
        scrollTop=document.body.scrollTop;    
    }    
    return scrollTop;    
} 

```



```js
/**
 * Created by Administrator on 2017/4/18.
 */
/**为元素增加类属性 */
function addClass(elements, value)
{
    if (!elements.className) {
        elements.className = value;
    }
    else
    {
        newClass = elements.className;
        newClass += " ";
        newClass += value;
        elements.className = newClass;
    }
}
 
/**获取根据参数名url的参数*/
 
function getParamsId(key) {
    var reg = new RegExp("(^|&)" + key + "=([^&]*)(&|$)");
 
    var loc=decodeURI(window.location.search);
    // alert(r);
    var r = loc.substr(1).match(reg);
    if (r != null) {
        return unescape(r[2]);
    }
    return null;
};
 
/**个人中心获取id值*/
 
function getParams(key) {
    var r = window.location;
    r=r.toString();
    var strArray=r.split('/');
 
    var pernalId=strArray[strArray.length-1];
 
    return pernalId;
 
}
 
 
 
 
/** 获取json数组的长度*/
 
function getJsonLength(json){
    var jsonLength=0;
    for (var i in json) {
        jsonLength++;
    }
    return jsonLength;
}
 
 
/**判断时间大小*/
function judgeTime(startTime,endTime) {
    var startTime =new Date(startTime.replace("//-/g", "//"));
    var endTime = new Date(endTime.replace("//-/g", "//"));
 
    return startTime<endTime;
}
 
 
/**判断时间间隔多少小时*/
function judgeTimeDiffer(startTime,endTime) {
    var startTime =new Date(startTime.replace("//-/g", "//"));
    var endTime = new Date(endTime.replace("//-/g", "//"));
 
    return parseInt((startTime.getTime() - endTime.getTime()) / 1000 / 60 / 60);
}
 
 
/**获取当前点击时的坐标位置*/
function getMousePos(event) {
    var e = event || window.event;
    var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
    var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
    var x = e.pageX || e.clientX + scrollX;
    var y = e.pageY || e.clientY + scrollY;
    //alert('x: ' + x + '\ny: ' + y);
    return { 'x': x, 'y': y };
}
 
/**获取屏幕中央的位置*/
 
function  getMiddleLocation(event) {
    var e = event || window.event;
    var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
    var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
 
    var x = scrollX ;
    var y =  scrollY ;
    return { 'x': x, 'y': y };
}

```

 888
# js获取各种宽高	

[链接1](https://blog.csdn.net/qq_15626693/article/details/54618276)

[链接2](https://www.cnblogs.com/iflygofy/p/5209725.html)

### **显示器的屏幕信息**

1. screeen.height:屏幕分辨率的高
2. screen.width:屏幕分辨率的宽
3. 前面这两个数表示：屏幕宽高(屏幕像素) ---- 定值
4. screen.availHeight:屏幕可用高度（屏幕分辨率的高度-上下测任务栏的高度）
5. screen.availWidth:屏幕可用宽度（屏幕分辨率的宽度-左右侧任务栏的宽度）
6. 前面这两个数表示：屏幕可用宽高(像素) ---- 定值

![img](P:\Users\Fergson.H\note\ud-img\20170119173647334.png)

### **浏览器信息**

1. window.outerHeight:浏览器高度
2. window.innerHeight:浏览器可用高度
3. 工具栏高度=window.outerHeight-window.innerHeight;
4. 相应的还有window.outerWidth、window.innerWidth

![img](P:\Users\Fergson.H\note\ud-img\20170119175053609.png)

### **页面信息**

1. document.body.offsetHeight: body的总高度，也成为网页可见区域的高度（包括边框宽度）
2. document.body.offsetWidth: body的总宽度，也成为网页可见区域的宽度（包括边框宽度）\
3. document.body.clientHeight: body向用户展示的高度，也成为网页可见区域的高度（不包括边框宽度）
4. document.body.clientWidth: body向用户展示的宽度，也成为网页可见区域的宽度（不包括边框宽度）
5. offsetWidthh和clientWidth会随着浏览器窗口的大小变化而发生改变，而offsetHeight和clientHeight就不会发生变化，可以理解为一个定值
6. documwnt.body.scrollHeight=document.body.clientHeight：body的滚动高度
7. documwnt.body.scrollWidth: body的滚动宽度
8. scrollHeight：对象的滚动高度为对象的height值
9. scrollWidth：对象的滚动宽度为对象的width值

![img](P:\Users\Fergson.H\note\ud-img\20170119180615096.png)

总之：

clientWidth=width+padding

offsetWidth=clientWidth+border



 888
 888
# zhengze 888
## 2019 年编写现代 JavaScript 代码的5个小技巧

[链接](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&mid=2651496983&idx=1&sn=bd97b20b8339e220aea4cff70056e5a5&chksm=80f1abdfb78622c9a594f8976b06b34aa7f4e300768c3ec7bd65fe6219395e1f4afbb4e09058&mpshare=1&scene=1&srcid=0123nJLprKuDMLJDPmTWVUDk&key=6e5e6d2df7d1a731c73d8fd8b1789dbb0c908e399bdc6791d4111b7ff55ac99bfd43fd1e9975720f3677d4173518b160cb644fc2787d58c69c9cea9af36b18cb140524b34dd431c471aa92ce6ee54844&ascene=1&uin=MTE3NjE0MDIwMg%3D%3D&devicetype=Windows-QQBrowser&version=6103000b&lang=zh_CN&pass_ticket=eDk827Faphrg%2F1YdPlMPz9u5k7juZyQPJ4mbKrp7Qy%2BhyqmoQO3B4VsU09ZqGIfR)

## 1 Array.includes 与条件判断

一般我们判断或用 ||

```
// conditionfunction test(fruit) {  if (fruit == "apple" || fruit == "strawberry") {    console.log("red");  }}
```

如果我们有更多水果

```
function test(fruit) {  const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
  if (redFruits.includes(fruit)) {    console.log("red");  }}
```

## 2 Set 与去重

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。

数组去重

```
const arr = [3, 5, 2, 2, 5, 5];const unique = [...new Set(arr)];// [3,5,2]
```

Array.from 方法可以将 Set 结构转为数组。我们可以专门编写使用一个去重的函数

```
function unique(array) {  return Array.from(new Set(array));}
unique([1, 1, 2, 3]); // [1, 2, 3]
```

字符去重

```
let str = [...new Set("ababbc")].join("");console.log(str);// 'abc'
```

另外 Set 是如此强大，因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。

```
let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);
// 并集let union = new Set([...a, ...b]);// Set {1, 2, 3, 4}
// 交集let intersect = new Set([...a].filter(x => b.has(x)));// set {2, 3}
// 差集let difference = new Set([...a].filter(x => !b.has(x)));// Set {1}
```

## 3 Map 与字典类型数据

一般而已，JavaScript 实现字典数据是基于 Object 对象。但是 JavaScript 的对象的键只能是字符串。对于编程来说有很多不便。 ES6 提供了 Map 数据结构。它类似于 Object 对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值，字符串、数值、布尔值、数组、对象等等都可以当作键。

```
const resultMap = new Map()  .set(-1, {text:'小于',color:'yellow')  .set(0, {text:'等于',color:'black')  .set(1, {text:'大于',color:'green')  .set(null,{text:'没有物品',color:'red'})
let state = resultMap.get(null)// {text:'没有物品',color:'red'}
```

Map 的遍历顺序就是插入顺序

```
const map = new Map([["F", "no"], ["T", "yes"]]);
for (let key of map.keys) {  console.log(key);}// "F"// "T"
for (let value of map.value()) {  console.log(value);}// "no"// "yes"
```

## 4 函数式的方式处理数据

按照我的理解，函数式编程主张函数必须接受至少一个参数并返回一个值。所以所有的关于数据的操作，都可以用函数式的方式处理。

假设我们有这样的需求，需要先把数组 foo 中的对象结构更改，然后从中挑选出一些符合条件的对象，并且把这些对象放进新数组 result 里。

```
let foo = [  {    name: "Stark",    age: 21  },  {    name: "Jarvis",    age: 20  },  {    name: "Pepper",    age: 16  }];
//我们希望得到结构稍微不同，age大于16的对象：let result = [  {    person: {      name: "Stark",      age: 21    },    friends: []  },  {    person: {      name: "Jarvis",      age: 20    },    friends: []  }];
```

从直觉上我们很容易写出这样的代码：

```
let result = [];
//有时甚至是普通的for循环foo.forEach(function(person){    if(person.age > 16){        let newItem = {            person: person,            friends: [];        };        result.push(newItem);    }})
```

使用函数式的写法，可以优雅得多

```
let result = foo  .filter(person => person.age > 16)  .map(person => ({    person: person,    friends: []  }));
```

数组求和

```
let foo = [1, 2, 3, 4, 5];
//不优雅function sum(arr) {  let x = 0;  for (let i = 0; i < arr.length; i++) {    x += arr[i];  }  return x;}sum(foo); // => 15
//优雅foo.reduce((a, b) => a + b); // => 15
```

## 5 compose 与函数组合

以下代码称为组合 compose

```
const compose = function(f, g) {  return function(x) {    return f(g(x));  };};
```

由于函数式编程大行其道，所以现在将会在 JavaScript 代码看到大量的箭头()=>()=>()=>的代码。

ES6 版本 compose

```
const compose = (f, g) => x => f(g(x));
```

在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据 流。这样做的可读性远远高于嵌套一大堆的函数调用.

我们选择一些函数，让它们结合，生成一个崭新的函数。

reverse 反转列表， head 取列表中的第一个元素；

```
const head = arr => arr[0];const reverse = arr => [].concat(arr).reverse();
const last = compose(head, reverse);last(["jumpkick", "roundhouse", "uppercut"]);// "uppercut"
```

但是我们这个这个compose不够完善，只能处理两个函数参数。redux源码有个很完备的compose函数，我们借鉴一下。

```
function compose(...funcs){  if (funcs.length === 0){      return arg => arg  }
  if (funcs.length === 1 ){      return funcs[0]  }
  return funcs.reduce((a,b)=>(...args) => a(b(...args)))}
```

有了这个函数，我们可以随意组合无数个函数。现在我们增加需求，组合出一个lastAndUpper函数，内容是先reverse 反转列表， head 取列表中的第一个元素, 最后toUpperCase大写。

```
const head = arr => arr[0];const reverse = arr => [].concat(arr).reverse();const toUpperCase = str => str.toUpperCase();
const last = compose(head, reverse);
const lastAndUpper = compose(toUpperCase, head, reverse,);
console.log(last(["jumpkick", "roundhouse", "uppercut"]));// "uppercut"console.log(lastAndUpper(["jumpkick", "roundhouse", "uppercut"]))// "UPPERCUT"
```

##  888
# 淘宝rem自适应代码

[GitHub链接](https://github.com/amfe/lib-flexible/blob/2.0/index.js)

```js
(function flexible (window, document) {
  var docEl = document.documentElement
  var dpr = window.devicePixelRatio || 1

  // adjust body font size
  function setBodyFontSize () {
    if (document.body) {
      document.body.style.fontSize = (12 * dpr) + 'px'
    }
    else {
      document.addEventListener('DOMContentLoaded', setBodyFontSize)
    }
  }
  setBodyFontSize();

  // set 1rem = viewWidth / 10
  function setRemUnit () {
    var rem = docEl.clientWidth / 10
    docEl.style.fontSize = rem + 'px'
  }

  setRemUnit()

  // reset rem unit on page resize
  window.addEventListener('resize', setRemUnit)
  window.addEventListener('pageshow', function (e) {
    if (e.persisted) {
      setRemUnit()
    }
  })

  // detect 0.5px supports
  if (dpr >= 2) {
    var fakeBody = document.createElement('body')
    var testElement = document.createElement('div')
    testElement.style.border = '.5px solid transparent'
    fakeBody.appendChild(testElement)
    docEl.appendChild(fakeBody)
    if (testElement.offsetHeight === 1) {
      docEl.classList.add('hairlines')
    }
    docEl.removeChild(fakeBody)
  }
}(window, document))
```

 888
# nodejs读取文件内容并替换

[链接](https://blog.csdn.net/weixin_41978390/article/details/80053865 )

```js
var fs = require('fs')
var path=require('path');
 
var filePath=path.resolve(__dirname+'/js');  
//readdir方法读取文件名
//readFile方法读取文件内容
//writeFile改写文件内容
fs.readdir(filePath, 'utf8', function (err,data) {
 
	data.forEach(function(item, index) {
		//console.log(item)
		fs.readFile('./js/'+item,'utf8',function(err,files){
			//console.log(files)
			var result = files.replace(/要替换的内容/g, '替换后的内容');
 
			fs.writeFile('./js/'+item, result, 'utf8', function (err) {
			     if (err) return console.log(err);
			});
 
		})
	});
 
```

 888
## 在item2中无法写入crontab

错误如图：

![image-20190118112127958](https://raw.githubusercontent.com/loveagri/note/master/ud-img/image-20190118112127958.png)

[解决方法](https://gitlab.com/gnachman/iterm2/issues/7088)

```
If you allow iTerm Full Disk Access in System Preferences (System Preferences -> Security & Privacy -> Privacy -> Full Disk Access), you'll be able to edit your crontab.
```

> 其实就是修改电脑里安全设置里的完全磁盘访问权限

 888
 888
 888
# APP打包步骤 

1. 安装Android studio 及 gradle

   1. 下载Android studio

   2. 傻瓜安装

   3. 安装java8环境

   4. 安装gradle

   5. Gradle路径不对许使用绝对路径

   6. 如果遇到缺少sdk 27或28level环境的问题，需在Android studio里安装

   7. 配置java,gradle环境变量

       ```bash
          PATH="/usr/local/opt/php@7.2/bin:$PATH"
          export PATH="/usr/local/opt/php@7.2/sbin:$PATH"
          export PATH=/Users/intech/gradle/gradle-4.6/bin:$PATH
          export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/ant/bin:/opt/reverse:$PATH
          export JAVA_HOME=$(/usr/libexec/java_home)
          export PATH=$JAVA_HOME/bin:$PATH
          export CLASS_PATH=$JAVA_HOME/lib
       ```
      ```
   
      
      ```

2. [安装pop的iOS包管理](https://www.jianshu.com/p/f43b5964f582)
    2019.01.03最新的CocoaPods安装教程

     1、查看当前Ruby版本

    ```bash
    ruby -v
    ```

    2、更换源

    ```bash
        sudo gem update --system
    
        gem sources --remove https://rubygems.org/
    
        gem sources --add https://gems.ruby-china.com/
    ```

    3、为了验证你的Ruby镜像是并且仅是ruby-china，执行以下命令查看

    ```sh
    gem sources -l
    
    *** CURRENT SOURCES ***
    
    https://gems.ruby-china.com/
    ```


    4、这时候才正式开始安装CocoaPods
    
    ```sh
    sudo gem install -n /usr/local/bin cocoapods
    ```

    5、如果安装了多个Xcode使用下面的命令选择（一般需要选择最近的Xcode版本）
    
    ```
    sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer
    ```


​    

    6、安装本地库
    
    ```sh
    pod setup
    ```


    如果command line tools找不到，则进入xcode->perferece->locations->command line tools切换选项
    
    证书：[安装p12文件 和 证书mobileprovision文件](https://blog.csdn.net/xxw888/article/details/73640139)


​    


	另外还需要ExportOptions.plist拷贝到制定的项目下，其作用是配置工程的证书设置



​	如果遇到codesign的问题请检查证书[559c1800-38ab-42f3-950c-ab545eeda3f2.mobileprovision](https://raw.githubusercontent.com/loveagri/note/master/ud-file/)



go服务启动脚本 nohup ./httpfs -addr :port

如果遇到某些文件或文件夹生成后是read-only,需查看php的php-fpm是否启动，若启动看是否是root用户运行

如果遇到build时出现打包错误：

1. tmp/cache, tmp/lock是否存在,并且具有写的权限
 888
<center><h1>Mac开机自启动NGINX和PHP</h1></center>

[Mac开机自启动NGINX和PHP](https://cn.aliyun.com/jiaocheng/696856.html)

1. 开机启动nginx:

在 /Library/LaunchDaemons/ 目录新建 org.macports.nginx.plist 文件:

```
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//ENhttp://www.apple.com/DTDs/PropertyList-1.0.dtd ><plist version="1.0"><dict> <key>Label</key> <string>org.macports.nginx</string> <key>ProgramArguments</key> <array> <string>/usr/local/bin/nginx</string> </array> <key>KeepAlive</key> <true/></dict></plist>
```



加载配置:launchctl load -w /Library/LaunchDaemons/org.macports.nginx.plist

2. 开机启动php:

在 /Library/LaunchDaemons/ 目录新建 org.php.php-fpm.plist 文件:

```
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//ENhttp://www.apple.com/DTDs/PropertyList-1.0.dtd ><plist version="1.0"><dict> <key>Label</key> <string>org.php.php-fpm</string> <key>ProgramArguments</key> <array> <string>/usr/sbin/php-fpm</string> </array> <key>KeepAlive</key> <true/></dict></plist>
```



加载配置:launchctl load -w /Library/LaunchDaemons/org.php.php-fpm.plist

Reference: launchd.plist-- System wide and per-user daemon/agent configuration files 888
# NGINX编译安装

--prefix=/usr/local/Cellar/nginx/1.15.8 --sbin-path=/usr/local/Cellar/nginx/1.15.8/bin/nginx --with-cc-opt='-I/usr/local/opt/pcre/include -I/usr/local/opt/openssl/include' --with-ld-opt='-L/usr/local/opt/pcre/lib -L/usr/local/opt/openssl/lib' --conf-path=/usr/local/etc/nginx/nginx.conf --pid-path=/usr/local/var/run/nginx.pid --lock-path=/usr/local/var/run/nginx.lock --http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp --http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp --http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp --http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp --http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp --http-log-path=/usr/local/var/log/nginx/access.log --error-log-path=/usr/local/var/log/nginx/error.log --with-debug --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-ipv6 --with-mail --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module

> 来brew install nginx的默认参数配置 888
 888
### Link
[npm 私服工具verdaccio 搭建(一)](https://blog.csdn.net/yyzzhc999/article/details/80097073) |
[npm 私服工具verdaccio 搭建(二)](https://blog.csdn.net/YYZZHC999/article/details/80114218) | 
[NodeJS学习：搭建私有NPM](http://www.cnblogs.com/HCJJ/p/9222826.html) | 
[pm2 status errored](https://blog.csdn.net/weixin_41451294/article/details/82791928) | 
[记录windows环境下用verdaccio搭建npm私有库](https://blog.csdn.net/weixin_43249693/article/details/84453017) | 
[gitlab之webhook自动部署](https://www.jianshu.com/p/00bc0323e83f) 


## 1.install node

下载最新的node环境，下载地址：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)

```shell
    #!/bin/bash
    wget https://nodejs.org/dist/v10.14.1/node-v10.14.1-linux-x64.tar.xz

    tar -zxvf node-v10.14.1-linux-x64

    cp node-v10.14.1-linux-x64 /usr/local/node

```

### 2.安装verdaccio
加上–unsafe-perm的原因是防止报grywarn权限的错。

```shell
npm install -g verdaccio --unsafe-perm
```

### 3. 配置
#### 3.1. 修改配置文件
verdaccio 的特点是，你在哪个目录运行，它的就会在对应的目录下创建自己的文件。目录下默认有两个文件：config.yaml和storage，htpasswd 是添加用户之后自动创建的；
由于第一次启动默认的config.xml文件是从原始文件default.yaml拷贝而来，可先修改verdaccio 原始的default.yaml。
地址：verdaccio 安装目录/conf/ default.yaml。
打开默认启动的config.yaml文件。

```
vim /home/admin/.config/verdaccio/config.yaml
```

在配置文件最后添加监听端口，配置文件详解请见文末尾

listen: 0.0.0.0:4873                    # listen on all addresses 
1
####3.2. 对外开放4873端口
verdaccio继承了sinopia，端口号4873依然不变。

firewall-cmd --state                # 先查看防火墙状态，
service firewalld start              # 开启防火墙:
firewall-cmd --zone=public --add-port=4873/tcp –permanent  #开放4873端口
firewall-cmd --reload              #重新载入
firewall-cmd --zone=public --query-port=4873/tcp    #查看是否添加成功
###4.启动verdaccio

4.1.verdaccio直接启动
命令：

verdaccio
1
// 显示信息，
第一句是配置文件的地址，
第二句，给了我们地址，访问便可以看到我们的私服已经搭建成功了。
目前还没有往上发布过包，所以没有任何包的信息。当我们打开页面还可以看到服务器这边有访问记录，控制台的日志一直在打。
verdaccio doesn‘t need superuser privileges. Don‘t run it und
warn — config file - /home/admin/.config/verdaccio/config.yaml
warn — http address - http://localhost:4873/ - verdaccio/


4.2 pm2守护verdaccio进程
利用第一种方法虽然可以正常启动和使用verdaccio，但不建议用这种方式启动verdaccio，我们可以用pm2来使用pm2对verdaccio进程进行托管启动。
安装pm2并使用pm2启动verdaccio，使用pm2托管的进程可以保证进程永远是活着的，尝试通过kill -9去杀verdaccio的进程发现杀了之后又自动启起来。推荐使用此种方式启动verdaccio.

#####4.2.1安装pm2

npm install -g pm2 --unsafe-perm
1
#####4.2.2使用pm2启动verdaccio

pm2 start verdaccio
1
####4.2.3 查看pm2 守护下的进程verdaccio的实时日志

pm2 show verdaccio          
1
通过这个命令我们可以从下图中看到所有verdaccio的所有信息，打开 out log path查看进程输出日志,出现错误时候也可以打开error log来查看错误日志。

实时查看该路径下的日志命令：

tail -f /home/admin/.pm2/logs/verdaccio-out-0.log     
1
添加用户
npm adduser --registry http://192.168.XX.XX:4873        //后面是我们的私服地址
类似如下：
Username: lk
Password: 
Email: (this IS public) lk@qq.com
Logged in as rong on http://192.168.XX.XX:4873/.
然后在verdaccion启动页面尝试登录即可，默认登录后有发布包的权限。(这里可以通过修改config.yaml配置文件来对权限进行设置)、

到这里服务器端的搭建就完毕了，下篇我们来介绍客户端如何使用。
 888


<center><h1>Npm使用npm-check选择升级所有可更新包(全局+局部) + 项目单个依 </h1></center> 

原文地址：[https://blog.csdn.net/pcaxb/article/details/81773475](https://blog.csdn.net/pcaxb/article/details/81773475)

## 1.安装npm-check： （全局目录安装）

```js
npm install -g npm-check
```

## 2.npm 全局更新包 (全局目录)

```js
npm-check -u -g
```

> 通过上下键可以移动光标，使用空格键可以选择需要处理的包，回车直接进行处理。

## 3.npm更新某个项目的包 （项目目录）

```js
npm-check -u
```

> 通过上下键可以移动光标，使用空格键可以选择需要处理的包，回车直接进行处理。
>
> 通过npm-check -u 就可以，不需要--save就可以直接更新package.json里面的内容

## 4.npm 更新单个全局包

```js
npm update <name> -g
```

## 5.npm 更新 项目 生产环境依赖包

```js
npm update <name> --save
```

## 6.npm 更新 项目 开发环境依赖包

```js
npm update <name> --save-dev
```

## 7.npm 查找全局安装过的包

```js

```

















---------------------




 888
[linux下编译安装最新版phalcon centos下PHP7添加phalcon扩展](https://blog.csdn.net/u010474681/article/details/78441468)



## linux下编译安装phalcon

### 1、下载源码包   

[phalcon包](https://github.com/phalcon/cphalcon/releases)

git clone --depth=1 git://github.com/phalcon/cphalcon.git

​			

进入目录 
运行命令：  cd build


执行安装文件  提示需要指定PHP的配置文件


运行命令：  ./install --php-config /usr/local/php/bin/php-config --phpize /usr/local/php/bin/phpize

安装过程可能中断，提示需要re2c
然后去下载
运行命令：  wget https://jaist.dl.sourceforge.net/project/re2c/old/re2c-0.13.4.tar.gz

​			brew install automake #安装aclocal命令

解压，编译安装。


然后重新再执行phalcon的
运行命令：  ./install --php-config /usr/local/php/bin/php-config --phpize /usr/local/php/bin/phpize


编译完成之后，提示安装成功。

### 2、修改php.ini 添加phalcon.so扩展

运行命令： vi /usr/local/php/etc/php.ini

![image-20190116155126097](/Users/intech/Library/Application Support/typora-user-images/image-20190116155126097.png)





添加内容： extension="phalcon.so"
然后保存，重启php。





### 3、测试是否安装成功

web目录里新建 test.php
<?php  
var_dump(get_loaded_extensions());
?>

![image-20190116155209383](/Users/intech/Library/Application Support/typora-user-images/image-20190116155209383.png)



运行后看到有 phalcon扩展被加载， 即是安装phalcon框架成功。 888
 888
# [mac php-fpm 守护进程运行](https://blog.csdn.net/weixin_36429334/article/details/83021052 )

问题是没有开启守护进程运行，php-fpm的时候出现 ready to handle connections … 关闭命令行窗口后又断开了 php-fpm ready to handle connections

解决方法：
1、首先要保证安装的PHP程序没有问题，因为我朋友启动php-fpm，网站的php文件依然可以解析，说明安装的程序没有任何问题。

2、查看php-fpm配置文件，因为php-fpm配置文件有一个选项是：

daemonize = yes

后台执行fpm，默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。
vi /usr/local/etc/php/7.2/php-fpm.conf 这个是配置文件

但是我查看我朋友的php-fpm.conf配置文件，却发现它的“daemonize = no ”，因此只需要改过来就解决了！

 888
 888
# PHP 获取今日、昨日、本周、上周、本月的等等常用的起始时间戳和结束时间戳的时间处理类

```php
<?php
class Time
{
    /**
     * 返回今日开始和结束的时间戳
     *
     * @return array
     */
    public static function today()
    {
        return [
            mktime(0, 0, 0, date('m'), date('d'), date('Y')),
            mktime(23, 59, 59, date('m'), date('d'), date('Y'))
        ];
    }
 
    /**
     * 返回昨日开始和结束的时间戳
     *
     * @return array
     */
    public static function yesterday()
    {
        $yesterday = date('d') - 1;
        return [
            mktime(0, 0, 0, date('m'), $yesterday, date('Y')),
            mktime(23, 59, 59, date('m'), $yesterday, date('Y'))
        ];
    }
 
    /**
     * 返回本周开始和结束的时间戳
     *
     * @return array
     */
    public static function week()
    {
        $timestamp = time();
        return [
            strtotime(date('Y-m-d', strtotime("this week Monday", $timestamp))),
            strtotime(date('Y-m-d', strtotime("this week Sunday", $timestamp))) + 24 * 3600 - 1
        ];
    }
 
    /**
     * 返回上周开始和结束的时间戳
     *
     * @return array
     */
    public static function lastWeek()
    {
        $timestamp = time();
        return [
            strtotime(date('Y-m-d', strtotime("last week Monday", $timestamp))),
            strtotime(date('Y-m-d', strtotime("last week Sunday", $timestamp))) + 24 * 3600 - 1
        ];
    }
 
    /**
     * 返回本月开始和结束的时间戳
     *
     * @return array
     */
    public static function month($everyDay = false)
    {
        return [
            mktime(0, 0, 0, date('m'), 1, date('Y')),
            mktime(23, 59, 59, date('m'), date('t'), date('Y'))
        ];
    }
 
    /**
     * 返回上个月开始和结束的时间戳
     *
     * @return array
     */
    public static function lastMonth()
    {
        $begin = mktime(0, 0, 0, date('m') - 1, 1, date('Y'));
        $end = mktime(23, 59, 59, date('m') - 1, date('t', $begin), date('Y'));
 
        return [$begin, $end];
    }
 
    /**
     * 返回今年开始和结束的时间戳
     *
     * @return array
     */
    public static function year()
    {
        return [
            mktime(0, 0, 0, 1, 1, date('Y')),
            mktime(23, 59, 59, 12, 31, date('Y'))
        ];
    }
 
    /**
     * 返回去年开始和结束的时间戳
     *
     * @return array
     */
    public static function lastYear()
    {
        $year = date('Y') - 1;
        return [
            mktime(0, 0, 0, 1, 1, $year),
            mktime(23, 59, 59, 12, 31, $year)
        ];
    }
 
    public static function dayOf()
    {
 
    }
 
    /**
     * 获取几天前零点到现在/昨日结束的时间戳
     *
     * @param int $day 天数
     * @param bool $now 返回现在或者昨天结束时间戳
     * @return array
     */
    public static function dayToNow($day = 1, $now = true)
    {
        $end = time();
        if (!$now) {
            list($foo, $end) = self::yesterday();
        }
 
        return [
            mktime(0, 0, 0, date('m'), date('d') - $day, date('Y')),
            $end
        ];
    }
 
    /**
     * 返回几天前的时间戳
     *
     * @param int $day
     * @return int
     */
    public static function daysAgo($day = 1)
    {
        $nowTime = time();
        return $nowTime - self::daysToSecond($day);
    }
 
    /**
     * 返回几天后的时间戳
     *
     * @param int $day
     * @return int
     */
    public static function daysAfter($day = 1)
    {
        $nowTime = time();
        return $nowTime + self::daysToSecond($day);
    }
 
    /**
     * 天数转换成秒数
     *
     * @param int $day
     * @return int
     */
    public static function daysToSecond($day = 1)
    {
        return $day * 86400;
    }
 
    /**
     * 周数转换成秒数
     *
     * @param int $week
     * @return int
     */
    public static function weekToSecond($week = 1)
    {
        return self::daysToSecond() * 7 * $week;
    }
 
    private static function startTimeToEndTime()
    {
 
    }
}
 
?>
```

[link:https://blog.csdn.net/mad_geek/article/details/72726086](https://blog.csdn.net/mad_geek/article/details/72726086)



 888
# [让PIP源使用国内镜像，提升下载速度和安装成功率。](https://www.cnblogs.com/microman/p/6107879.html)



对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。

## 国内源：

新版ubuntu要求使用https源，要注意。

清华：https://pypi.tuna.tsinghua.edu.cn/simple

阿里云：http://mirrors.aliyun.com/pypi/simple/

中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/

华中理工大学：http://pypi.hustunique.com/

山东理工大学：http://pypi.sdutlinux.org/ 

豆瓣：http://pypi.douban.com/simple/

## 临时使用：

可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple

例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。
 

## 永久修改，一劳永逸：

Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)

内容如下：

```
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host=mirrors.aliyun.com //set trusted proxy host| --trusted-host
```

windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。 888
 888
<center><h2>Rem与Px的转换</h2></center>



[https://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html](https://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html)



```
$baseFontSizePx: 16px !default;//变量的值可以根据自己需求定义

@mixin remCalc($property, $values...) {
  $pxValues: '';
  $remValues: '';
  $baseFontSize: $baseFontSizePx / ($baseFontSizePx * 0 + 1);
  @each $value in $values {
    $pxValues: #{$pxValues + ' ' + $value * $baseFontSize}px;
    $remValues: #{$remValues + ' ' + $value}rem;
  }
  #{$property}: $pxValues;
  #{$property}: $remValues;
}

@mixin pxCalc($property, $values...) {
  $pxValues: '';
  $remValues: '';
  $baseFontSize: $baseFontSizePx / ($baseFontSizePx * 0 + 1);
  @each $value in $values {
    $pxValues: #{$pxValues + ' ' + $value}px;
    $remValues: #{$remValues + ' ' + $value / $baseFontSize}rem;
  }
  #{$property}: $pxValues;
  #{$property}: $remValues;
}

@function pxToRem($px){ @return $px / $baseFontSizePx * 1rem; }


.wrapper {
  @include remCalc(width,32);
  @include remCalc(margin,16,8,32,64);
  @include remCalc(border,16);
}


.px {
  @include pxCalc(width,32);
  @include pxCalc(margin,16,8,32,64);
  @include pxCalc(border,16,solid,red);
}
```

 888
 888
#### vim 中批量添加注释

##### 方法一 ：块选择模式

Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 **I** 进入行首插入模式输入注释符号如 **//** 或 **#**，输入完毕之后，按两下 **ESC**，**Vim** 会自动将你选中的所有行首都加上注释，保存退出完成注释。

取消注释：

Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 **//** 要选中两个，选好之后按 **d** 即可删除注释，

**ESC** 保存退出。

##### 方法二: 替换命令

批量注释。

使用下面命令在指定的行首添加注释。

使用名命令格式： :起始行号,结束行号s/^/注释符/g（注意冒号）。

取消注释：

使用名命令格式： :起始行号,结束行号s/^注释符//g（注意冒号）。

​	 888
 888
# Ubuntu

## uninstall

```sh
sudo apt remove vim
sudo apt autoremove
```

## install

```sh
sudo apt install vim
```

## help manual

```
Help -> :help -> :q/ZZ  //打开帮助文档

Version: :version //查看版本

Download chinese language -> sourceforge search -> vim documentation chinese version -> download -> files ->vimcdoc -> select tar package -> download -> unpackage -> readme/INSTALL -> ./vimcdoc.sh -i/./vimcdoc.sh -u -> :set helplang=en/:set helplang=cn to change language version

ctrl+] //跳转到当前光标所在单词的对应的主题
Ctrl+o 、、回到上一主题
```



 888
# [webpack将资源打成zip包](https://blog.csdn.net/XinZhongYi/article/details/80592599)



该插件允许你复制，打包，移动，删除文件及文件夹在build之前及之后。

安装：

​    npm install filemanager-webpack-plugin --save-dev

资源打zip包 Webpack.config.js：



```js
const FileManagerPlugin = require('filemanager-webpack-plugin');
    
new FileManagerPlugin({
  onEnd: {
    mkdir: ['./zip'],
    archive: [
      { source: './dist', destination: './zip/test.zip' },
    ]
  }
})

```

其他功能（移动，打包，复制）Webpack.config.js:



```js
const FileManagerPlugin = require('filemanager-webpack-plugin');
 
module.exports = {
  ...
  ...
  plugins: [
    new FileManagerPlugin({
      onEnd: {
        copy: [
          { source: '/path/from', destination: '/path/to' },
          { source: '/path/**/*.js', destination: '/path' },
          { source: '/path/fromfile.txt', destination: '/path/tofile.txt' },
          { source: '/path/**/*.{html,js}', destination: '/path/to' },
          { source: '/path/{file1,file2}.js', destination: '/path/to' },
          { source: '/path/file-[hash].js', destination: '/path/to' }
        ],
        move: [
          { source: '/path/from', destination: '/path/to' },
          { source: '/path/fromfile.txt', destination: '/path/tofile.txt' }
        ],
        delete: [
         '/path/to/file.txt',
         '/path/to/directory/'
        ],
        mkdir: [
         '/path/to/directory/',
         '/another/directory/'
        ],
        archive: [
          { source: '/path/from', destination: '/path/to.zip' },
          { source: '/path/**/*.js', destination: '/path/to.zip' },
          { source: '/path/fromfile.txt', destination: '/path/to.zip' },
          { source: '/path/fromfile.txt', destination: '/path/to.zip', format: 'tar' },
          { 
             source: '/path/fromfile.txt', 
             destination: '/path/to.tar.gz', 
             format: 'tar',
             options: {
               gzip: true,
               gzipOptions: {
                level: 1
               }
             }
           }
 
        ]
      }
    })
  ],
  ...
}

```





 888
[全栈博客](http://www.dohooe.com/)

里边记录了Android，iOS，PHP，Git，Mac，Linux等等

 888
# [让PIP源使用国内镜像，提升下载速度和安装成功率。](https://www.cnblogs.com/microman/p/6107879.html)

        对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。

## 国内源：

新版ubuntu要求使用https源，要注意。

清华：https://pypi.tuna.tsinghua.edu.cn/simple

阿里云：http://mirrors.aliyun.com/pypi/simple/

中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/

华中理工大学：http://pypi.hustunique.com/

山东理工大学：http://pypi.sdutlinux.org/ 

豆瓣：http://pypi.douban.com/simple/

## 临时使用：

可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple

例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。


## 永久修改，一劳永逸：

Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)

内容如下：

```
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host=mirrors.aliyun.com // set https trusted host,--trusted-host
```

windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。 888
 888
{% raw %}
<video id="my-video" class="video-js" controls preload="auto" width="100%"
poster="https://zhangjikai.com/resource/poster.jpg" data-setup='{"aspectRatio":"16:9"}'>
  <source src="https://zhangjikai.com/resource/demo.mp4" type='video/mp4' >
  <p class="vjs-no-js">
    To view this video please enable JavaScript, and consider upgrading to a web browser that
    <a href="http://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a>
  </p>
</video>
{% endraw %}

 888
# [Linux curl命令详解](https://www.cnblogs.com/duhuo/p/5695256.html)



## 命令：curl

在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。

```
语法：# curl [option] [url]
```

常见参数：

```
-A/--user-agent <string>              设置用户代理发送给服务器
-b/--cookie <name=string/file>    cookie字符串或文件读取位置
-c/--cookie-jar <file>                    操作结束后把cookie写入到这个文件中
-C/--continue-at <offset>            断点续转
-D/--dump-header <file>              把header信息写入到该文件中
-e/--referer                                  来源网址
-f/--fail                                          连接失败时不显示http错误
-o/--output                                  把输出写到该文件中
-O/--remote-name                      把输出写到该文件中，保留远程文件的文件名
-r/--range <range>                      检索来自HTTP/1.1或FTP服务器字节范围
-s/--silent                                    静音模式。不输出任何东西
-T/--upload-file <file>                  上传文件
-u/--user <user[:password]>      设置服务器的用户和密码
-w/--write-out [format]                什么输出完成后
-x/--proxy <host[:port]>              在给定的端口上使用HTTP代理
-#/--progress-bar                        进度条显示当前的传送状态
```

例子：
1、基本用法

```
# curl http://www.linux.com
```

执行后，www.linux.com 的html就会显示在屏幕上了
Ps：由于安装linux的时候很多时候是没有安装桌面的，也意味着没有浏览器，因此这个方法也经常用于测试一台服务器是否可以到达一个网站

2、保存访问的网页
2.1:使用linux的重定向功能保存

```
# curl http://www.linux.com >> linux.html
```

2.2:可以使用curl的内置option:-o(小写)保存网页

```
$ curl -o linux.html http://www.linux.com
```

执行完成后会显示如下界面，显示100%则表示保存成功

```
% Total    % Received % Xferd  Average Speed  Time    Time    Time  Current
                                Dload  Upload  Total  Spent    Left  Speed
100 79684    0 79684    0    0  3437k      0 --:--:-- --:--:-- --:--:-- 7781k
```

2.3:可以使用curl的内置option:-O(大写)保存网页中的文件
要注意这里后面的url要具体到某个文件，不然抓不下来

```
# curl -O http://www.linux.com/hello.sh
```

3、测试网页返回值

```
# curl -o /dev/null -s -w %{http_code} www.linux.com
```

Ps:在脚本中，这是很常见的测试网站是否正常的用法

4、指定proxy服务器以及其端口
很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理

```
# curl -x 192.168.100.100:1080 http://www.linux.com
```

5、cookie
有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie
5.1:保存http的response里面的cookie信息。内置option:-c（小写）

```
# curl -c cookiec.txt  http://www.linux.com
```

执行后cookie信息就被存到了cookiec.txt里面了

5.2:保存http的response里面的header信息。内置option: -D

```
# curl -D cookied.txt http://www.linux.com
```

执行后cookie信息就被存到了cookied.txt里面了

注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。


5.3:使用cookie
很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b

```
# curl -b cookiec.txt http://www.linux.com
```

6、模仿浏览器
有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站

```
# curl -A "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)" http://www.linux.com
```

这样服务器端就会认为是使用IE8.0去访问的

7、伪造referer（盗链）
很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了
curl中内置option：-e可以让我们设定referer

```
# curl -e "www.linux.com" http://mail.linux.com
```

这样就会让服务器其以为你是从www.linux.com点击某个链接过来的

8、下载文件
8.1：利用curl下载文件。
\#使用内置option：-o(小写)

```
# curl -o dodo1.jpg http:www.linux.com/dodo1.JPG
```

\#使用内置option：-O（大写)

```
# curl -O http://www.linux.com/dodo1.JPG
```

这样就会以服务器上的名称保存文件到本地

8.2：循环下载
有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样

```
# curl -O http://www.linux.com/dodo[1-5].JPG
```

这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来

8.3：下载重命名

```
# curl -O http://www.linux.com/{hello,bb}/dodo[1-5].JPG
```

由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。

```
# curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG
```

这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖

8.4：分块下载
有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r

```
# curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG
# curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG
# curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG
# cat dodo1_part* > dodo1.JPG
```

这样就可以查看dodo1.JPG的内容了

8.5：通过ftp下载文件
curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法

```
# curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG
# curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG
```

8.6：显示下载进度条

```
# curl -# -O http://www.linux.com/dodo1.JPG
```

8.7：不会显示下载进度信息

```
# curl -s -O http://www.linux.com/dodo1.JPG
```

9、断点续传
在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果
如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传

```
# curl -C -O http://www.linux.com/dodo1.JPG
```

10、上传文件
curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现

```
# curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/
```

这样就向ftp服务器上传了文件dodo1.JPG

11、显示抓取错误

```
# curl -f http://www.linux.com/error
```

其他参数(此处翻译为转载)：

```
-a/--append                        上传文件时，附加到目标文件
--anyauth                            可以使用“任何”身份验证方法
--basic                                使用HTTP基本验证
-B/--use-ascii                      使用ASCII文本传输
-d/--data <data>                  HTTP POST方式传送数据
--data-ascii <data>            以ascii的方式post数据
--data-binary <data>          以二进制的方式post数据
--negotiate                          使用HTTP身份验证
--digest                        使用数字身份验证
--disable-eprt                  禁止使用EPRT或LPRT
--disable-epsv                  禁止使用EPSV
--egd-file <file>              为随机数据(SSL)设置EGD socket路径
--tcp-nodelay                  使用TCP_NODELAY选项
-E/--cert <cert[:passwd]>      客户端证书文件和密码 (SSL)
--cert-type <type>              证书文件类型 (DER/PEM/ENG) (SSL)
--key <key>                    私钥文件名 (SSL)
--key-type <type>              私钥文件类型 (DER/PEM/ENG) (SSL)
--pass  <pass>                  私钥密码 (SSL)
--engine <eng>                  加密引擎使用 (SSL). "--engine list" for list
--cacert <file>                CA证书 (SSL)
--capath <directory>            CA目   (made using c_rehash) to verify peer against (SSL)
--ciphers <list>                SSL密码
--compressed                    要求返回是压缩的形势 (using deflate or gzip)
--connect-timeout <seconds>    设置最大请求时间
--create-dirs                  建立本地目录的目录层次结构
--crlf                          上传是把LF转变成CRLF
--ftp-create-dirs              如果远程目录不存在，创建远程目录
--ftp-method [multicwd/nocwd/singlecwd]    控制CWD的使用
--ftp-pasv                      使用 PASV/EPSV 代替端口
--ftp-skip-pasv-ip              使用PASV的时候,忽略该IP地址
--ftp-ssl                      尝试用 SSL/TLS 来进行ftp数据传输
--ftp-ssl-reqd                  要求用 SSL/TLS 来进行ftp数据传输
-F/--form <name=content>        模拟http表单提交数据
-form-string <name=string>      模拟http表单提交数据
-g/--globoff                    禁用网址序列和范围使用{}和[]
-G/--get                        以get的方式来发送数据
-h/--help                      帮助
-H/--header <line>              自定义头信息传递给服务器
--ignore-content-length        忽略的HTTP头信息的长度
-i/--include                    输出时包括protocol头信息
-I/--head                      只显示文档信息
-j/--junk-session-cookies      读取文件时忽略session cookie
--interface <interface>        使用指定网络接口/地址
--krb4 <level>                  使用指定安全级别的krb4
-k/--insecure                  允许不使用证书到SSL站点
-K/--config                    指定的配置文件读取
-l/--list-only                  列出ftp目录下的文件名称
--limit-rate <rate>            设置传输速度
--local-port<NUM>              强制使用本地端口号
-m/--max-time <seconds>        设置最大传输时间
--max-redirs <num>              设置最大读取的目录数
--max-filesize <bytes>          设置最大下载的文件总量
-M/--manual                    显示全手动
-n/--netrc                      从netrc文件中读取用户名和密码
--netrc-optional                使用 .netrc 或者 URL来覆盖-n
--ntlm                          使用 HTTP NTLM 身份验证
-N/--no-buffer                  禁用缓冲输出
-p/--proxytunnel                使用HTTP代理
--proxy-anyauth                选择任一代理身份验证方法
--proxy-basic                  在代理上使用基本身份验证
--proxy-digest                  在代理上使用数字身份验证
--proxy-ntlm                    在代理上使用ntlm身份验证
-P/--ftp-port <address>        使用端口地址，而不是使用PASV
-Q/--quote <cmd>                文件传输前，发送命令到服务器
--range-file                    读取（SSL）的随机文件
-R/--remote-time                在本地生成文件时，保留远程文件时间
--retry <num>                  传输出现问题时，重试的次数
--retry-delay <seconds>        传输出现问题时，设置重试间隔时间
--retry-max-time <seconds>      传输出现问题时，设置最大重试时间
-S/--show-error                显示错误
--socks4 <host[:port]>          用socks4代理给定主机和端口
--socks5 <host[:port]>          用socks5代理给定主机和端口
-t/--telnet-option <OPT=val>    Telnet选项设置
--trace <file>                  对指定文件进行debug
--trace-ascii <file>            Like --跟踪但没有hex输出
--trace-time                    跟踪/详细输出时，添加时间戳
--url <URL>                    Spet URL to work with
-U/--proxy-user <user[:password]>  设置代理用户名和密码
-V/--version                    显示版本信息
-X/--request <command>          指定什么命令
-y/--speed-time                放弃限速所要的时间。默认为30
-Y/--speed-limit                停止传输速度的限制，速度时间'秒
-z/--time-cond                  传送时间设置
-0/--http1.0                    使用HTTP 1.0
-1/--tlsv1                      使用TLSv1（SSL）
-2/--sslv2                      使用SSLv2的（SSL）
-3/--sslv3                      使用的SSLv3（SSL）
--3p-quote                      like -Q for the source URL for 3rd party transfer
--3p-url                        使用url，进行第三方传送
--3p-user                      使用用户名和密码，进行第三方传送
-4/--ipv4                      使用IP4
-6/--ipv6                      使用IP6
```

 888
