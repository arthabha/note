{"./":{"url":"./","title":"Introduction","keywords":"","body":"每天记录一点点 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-18 17:25:36 "},"git/":{"url":"git/","title":"git","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"git/git command.html":{"url":"git/git command.html","title":"git command","keywords":"","body":"[ Git使用教程](https://github.com/DickyQie/Tool-use/tree/git-learning-document) Git教程 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"git/git-reset-org.html":{"url":"git/git-reset-org.html","title":"git-reset-org","keywords":"","body":"git 放弃本地修改 https://www.cnblogs.com/qufanblog/p/7606105.html 一，未使用 git add 缓存代码时。 可以使用 git checkout -- filepathname (比如： git checkout -- readme.md ，不要忘记中间的 “--” ，不写就成了检出分支了！！)。放弃所有的文件修改可以使用 git checkout . 命令。 此命令用来放弃掉所有还没有加入到缓存区（就是 git add 命令）的修改：内容修改与整个文件删除。但是此命令不会删除掉刚新建的文件。因为刚新建的文件还没已有加入到 git 的管理系统中。所以对于git是未知的。自己手动删除就好了。 二，已经使用了 git add 缓存了代码。 可以使用 git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所以的缓存可以使用 git reset HEAD . 命令。 此命令用来清除 git 对于文件修改的缓存。相当于撤销 git add 命令所在的工作。在使用本命令后，本地的修改并不会消失，而是回到了如（一）所示的状态。继续用（一）中的操作，就可以放弃本地的修改。 三，已经用 git commit 提交了代码。 可以使用 git reset --hard HEAD^ 来回退到上一次commit的状态。此命令可以用来回退到任意版本：git reset --hard commitId 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"git/ssh-keygen.html":{"url":"git/ssh-keygen.html","title":"ssh-keygen","keywords":"","body":"Ssh-keygen生成过程 1：生成RSA key 过程 （1）在指定的用户目录下，右键打开git bash 执行 命名：ssh-agent bash （2）生成RSA密钥，执行命令：ssh-keygen -t rsa -C 742981086@qq.com （3）添加密钥到ssh，执行的命令：ssh-add 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"js/":{"url":"js/","title":"js","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"js/reg.html":{"url":"js/reg.html","title":"reg","keywords":"","body":"zhengze 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"js/skills.html":{"url":"js/skills.html","title":"skills","keywords":"","body":"2019 年编写现代 JavaScript 代码的5个小技巧 链接 1 Array.includes 与条件判断 一般我们判断或用 || // conditionfunction test(fruit) { if (fruit == \"apple\" || fruit == \"strawberry\") { console.log(\"red\"); }} 如果我们有更多水果 function test(fruit) { const redFruits = [\"apple\", \"strawberry\", \"cherry\", \"cranberries\"]; if (redFruits.includes(fruit)) { console.log(\"red\"); }} 2 Set 与去重 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。 数组去重 const arr = [3, 5, 2, 2, 5, 5];const unique = [...new Set(arr)];// [3,5,2] Array.from 方法可以将 Set 结构转为数组。我们可以专门编写使用一个去重的函数 function unique(array) { return Array.from(new Set(array));} unique([1, 1, 2, 3]); // [1, 2, 3] 字符去重 let str = [...new Set(\"ababbc\")].join(\"\");console.log(str);// 'abc' 另外 Set 是如此强大，因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]); // 并集let union = new Set([...a, ...b]);// Set {1, 2, 3, 4} // 交集let intersect = new Set([...a].filter(x => b.has(x)));// set {2, 3} // 差集let difference = new Set([...a].filter(x => !b.has(x)));// Set {1} 3 Map 与字典类型数据 一般而已，JavaScript 实现字典数据是基于 Object 对象。但是 JavaScript 的对象的键只能是字符串。对于编程来说有很多不便。 ES6 提供了 Map 数据结构。它类似于 Object 对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值，字符串、数值、布尔值、数组、对象等等都可以当作键。 const resultMap = new Map() .set(-1, {text:'小于',color:'yellow') .set(0, {text:'等于',color:'black') .set(1, {text:'大于',color:'green') .set(null,{text:'没有物品',color:'red'}) let state = resultMap.get(null)// {text:'没有物品',color:'red'} Map 的遍历顺序就是插入顺序 const map = new Map([[\"F\", \"no\"], [\"T\", \"yes\"]]); for (let key of map.keys) { console.log(key);}// \"F\"// \"T\" for (let value of map.value()) { console.log(value);}// \"no\"// \"yes\" 4 函数式的方式处理数据 按照我的理解，函数式编程主张函数必须接受至少一个参数并返回一个值。所以所有的关于数据的操作，都可以用函数式的方式处理。 假设我们有这样的需求，需要先把数组 foo 中的对象结构更改，然后从中挑选出一些符合条件的对象，并且把这些对象放进新数组 result 里。 let foo = [ { name: \"Stark\", age: 21 }, { name: \"Jarvis\", age: 20 }, { name: \"Pepper\", age: 16 }]; //我们希望得到结构稍微不同，age大于16的对象：let result = [ { person: { name: \"Stark\", age: 21 }, friends: [] }, { person: { name: \"Jarvis\", age: 20 }, friends: [] }]; 从直觉上我们很容易写出这样的代码： let result = []; //有时甚至是普通的for循环foo.forEach(function(person){ if(person.age > 16){ let newItem = { person: person, friends: []; }; result.push(newItem); }}) 使用函数式的写法，可以优雅得多 let result = foo .filter(person => person.age > 16) .map(person => ({ person: person, friends: [] })); 数组求和 let foo = [1, 2, 3, 4, 5]; //不优雅function sum(arr) { let x = 0; for (let i = 0; i 15 //优雅foo.reduce((a, b) => a + b); // => 15 5 compose 与函数组合 以下代码称为组合 compose const compose = function(f, g) { return function(x) { return f(g(x)); };}; 由于函数式编程大行其道，所以现在将会在 JavaScript 代码看到大量的箭头()=>()=>()=>的代码。 ES6 版本 compose const compose = (f, g) => x => f(g(x)); 在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据 流。这样做的可读性远远高于嵌套一大堆的函数调用. 我们选择一些函数，让它们结合，生成一个崭新的函数。 reverse 反转列表， head 取列表中的第一个元素； const head = arr => arr[0];const reverse = arr => [].concat(arr).reverse(); const last = compose(head, reverse);last([\"jumpkick\", \"roundhouse\", \"uppercut\"]);// \"uppercut\" 但是我们这个这个compose不够完善，只能处理两个函数参数。redux源码有个很完备的compose函数，我们借鉴一下。 function compose(...funcs){ if (funcs.length === 0){ return arg => arg } if (funcs.length === 1 ){ return funcs[0] } return funcs.reduce((a,b)=>(...args) => a(b(...args)))} 有了这个函数，我们可以随意组合无数个函数。现在我们增加需求，组合出一个lastAndUpper函数，内容是先reverse 反转列表， head 取列表中的第一个元素, 最后toUpperCase大写。 const head = arr => arr[0];const reverse = arr => [].concat(arr).reverse();const toUpperCase = str => str.toUpperCase(); const last = compose(head, reverse); const lastAndUpper = compose(toUpperCase, head, reverse,); console.log(last([\"jumpkick\", \"roundhouse\", \"uppercut\"]));// \"uppercut\"console.log(lastAndUpper([\"jumpkick\", \"roundhouse\", \"uppercut\"]))// \"UPPERCUT\" 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"js/正则读文件内容替换.html":{"url":"js/正则读文件内容替换.html","title":"正则读文件内容替换","keywords":"","body":"nodejs读取文件内容并替换 链接 var fs = require('fs') var path=require('path'); var filePath=path.resolve(__dirname+'/js'); //readdir方法读取文件名 //readFile方法读取文件内容 //writeFile改写文件内容 fs.readdir(filePath, 'utf8', function (err,data) { data.forEach(function(item, index) { //console.log(item) fs.readFile('./js/'+item,'utf8',function(err,files){ //console.log(files) var result = files.replace(/要替换的内容/g, '替换后的内容'); fs.writeFile('./js/'+item, result, 'utf8', function (err) { if (err) return console.log(err); }); }) }); 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"Linux/curl command.html":{"url":"Linux/curl command.html","title":"curl command","keywords":"","body":"Linux curl命令详解 命令：curl 在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 语法：# curl [option] [url] 常见参数： -A/--user-agent 设置用户代理发送给服务器 -b/--cookie cookie字符串或文件读取位置 -c/--cookie-jar 操作结束后把cookie写入到这个文件中 -C/--continue-at 断点续转 -D/--dump-header 把header信息写入到该文件中 -e/--referer 来源网址 -f/--fail 连接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -r/--range 检索来自HTTP/1.1或FTP服务器字节范围 -s/--silent 静音模式。不输出任何东西 -T/--upload-file 上传文件 -u/--user 设置服务器的用户和密码 -w/--write-out [format] 什么输出完成后 -x/--proxy 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态 例子： 1、基本用法 # curl http://www.linux.com 执行后，www.linux.com 的html就会显示在屏幕上了 Ps：由于安装linux的时候很多时候是没有安装桌面的，也意味着没有浏览器，因此这个方法也经常用于测试一台服务器是否可以到达一个网站 2、保存访问的网页 2.1:使用linux的重定向功能保存 # curl http://www.linux.com >> linux.html 2.2:可以使用curl的内置option:-o(小写)保存网页 $ curl -o linux.html http://www.linux.com 执行完成后会显示如下界面，显示100%则表示保存成功 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 79684 0 79684 0 0 3437k 0 --:--:-- --:--:-- --:--:-- 7781k 2.3:可以使用curl的内置option:-O(大写)保存网页中的文件 要注意这里后面的url要具体到某个文件，不然抓不下来 # curl -O http://www.linux.com/hello.sh 3、测试网页返回值 # curl -o /dev/null -s -w %{http_code} www.linux.com Ps:在脚本中，这是很常见的测试网站是否正常的用法 4、指定proxy服务器以及其端口 很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理 # curl -x 192.168.100.100:1080 http://www.linux.com 5、cookie 有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie 5.1:保存http的response里面的cookie信息。内置option:-c（小写） # curl -c cookiec.txt http://www.linux.com 执行后cookie信息就被存到了cookiec.txt里面了 5.2:保存http的response里面的header信息。内置option: -D # curl -D cookied.txt http://www.linux.com 执行后cookie信息就被存到了cookied.txt里面了 注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。 5.3:使用cookie 很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b # curl -b cookiec.txt http://www.linux.com 6、模仿浏览器 有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站 # curl -A \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)\" http://www.linux.com 这样服务器端就会认为是使用IE8.0去访问的 7、伪造referer（盗链） 很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了 curl中内置option：-e可以让我们设定referer # curl -e \"www.linux.com\" http://mail.linux.com 这样就会让服务器其以为你是从www.linux.com点击某个链接过来的 8、下载文件 8.1：利用curl下载文件。 #使用内置option：-o(小写) # curl -o dodo1.jpg http:www.linux.com/dodo1.JPG #使用内置option：-O（大写) # curl -O http://www.linux.com/dodo1.JPG 这样就会以服务器上的名称保存文件到本地 8.2：循环下载 有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样 # curl -O http://www.linux.com/dodo[1-5].JPG 这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来 8.3：下载重命名 # curl -O http://www.linux.com/{hello,bb}/dodo[1-5].JPG 由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。 # curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG 这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖 8.4：分块下载 有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r # curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG # curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG # curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG # cat dodo1_part* > dodo1.JPG 这样就可以查看dodo1.JPG的内容了 8.5：通过ftp下载文件 curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法 # curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG # curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG 8.6：显示下载进度条 # curl -# -O http://www.linux.com/dodo1.JPG 8.7：不会显示下载进度信息 # curl -s -O http://www.linux.com/dodo1.JPG 9、断点续传 在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果 如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传 # curl -C -O http://www.linux.com/dodo1.JPG 10、上传文件 curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现 # curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/ 这样就向ftp服务器上传了文件dodo1.JPG 11、显示抓取错误 # curl -f http://www.linux.com/error 其他参数(此处翻译为转载)： -a/--append 上传文件时，附加到目标文件 --anyauth 可以使用“任何”身份验证方法 --basic 使用HTTP基本验证 -B/--use-ascii 使用ASCII文本传输 -d/--data HTTP POST方式传送数据 --data-ascii 以ascii的方式post数据 --data-binary 以二进制的方式post数据 --negotiate 使用HTTP身份验证 --digest 使用数字身份验证 --disable-eprt 禁止使用EPRT或LPRT --disable-epsv 禁止使用EPSV --egd-file 为随机数据(SSL)设置EGD socket路径 --tcp-nodelay 使用TCP_NODELAY选项 -E/--cert 客户端证书文件和密码 (SSL) --cert-type 证书文件类型 (DER/PEM/ENG) (SSL) --key 私钥文件名 (SSL) --key-type 私钥文件类型 (DER/PEM/ENG) (SSL) --pass 私钥密码 (SSL) --engine 加密引擎使用 (SSL). \"--engine list\" for list --cacert CA证书 (SSL) --capath CA目 (made using c_rehash) to verify peer against (SSL) --ciphers SSL密码 --compressed 要求返回是压缩的形势 (using deflate or gzip) --connect-timeout 设置最大请求时间 --create-dirs 建立本地目录的目录层次结构 --crlf 上传是把LF转变成CRLF --ftp-create-dirs 如果远程目录不存在，创建远程目录 --ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 --ftp-pasv 使用 PASV/EPSV 代替端口 --ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 --ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输 --ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输 -F/--form 模拟http表单提交数据 -form-string 模拟http表单提交数据 -g/--globoff 禁用网址序列和范围使用{}和[] -G/--get 以get的方式来发送数据 -h/--help 帮助 -H/--header 自定义头信息传递给服务器 --ignore-content-length 忽略的HTTP头信息的长度 -i/--include 输出时包括protocol头信息 -I/--head 只显示文档信息 -j/--junk-session-cookies 读取文件时忽略session cookie --interface 使用指定网络接口/地址 --krb4 使用指定安全级别的krb4 -k/--insecure 允许不使用证书到SSL站点 -K/--config 指定的配置文件读取 -l/--list-only 列出ftp目录下的文件名称 --limit-rate 设置传输速度 --local-port 强制使用本地端口号 -m/--max-time 设置最大传输时间 --max-redirs 设置最大读取的目录数 --max-filesize 设置最大下载的文件总量 -M/--manual 显示全手动 -n/--netrc 从netrc文件中读取用户名和密码 --netrc-optional 使用 .netrc 或者 URL来覆盖-n --ntlm 使用 HTTP NTLM 身份验证 -N/--no-buffer 禁用缓冲输出 -p/--proxytunnel 使用HTTP代理 --proxy-anyauth 选择任一代理身份验证方法 --proxy-basic 在代理上使用基本身份验证 --proxy-digest 在代理上使用数字身份验证 --proxy-ntlm 在代理上使用ntlm身份验证 -P/--ftp-port 使用端口地址，而不是使用PASV -Q/--quote 文件传输前，发送命令到服务器 --range-file 读取（SSL）的随机文件 -R/--remote-time 在本地生成文件时，保留远程文件时间 --retry 传输出现问题时，重试的次数 --retry-delay 传输出现问题时，设置重试间隔时间 --retry-max-time 传输出现问题时，设置最大重试时间 -S/--show-error 显示错误 --socks4 用socks4代理给定主机和端口 --socks5 用socks5代理给定主机和端口 -t/--telnet-option Telnet选项设置 --trace 对指定文件进行debug --trace-ascii Like --跟踪但没有hex输出 --trace-time 跟踪/详细输出时，添加时间戳 --url Spet URL to work with -U/--proxy-user 设置代理用户名和密码 -V/--version 显示版本信息 -X/--request 指定什么命令 -y/--speed-time 放弃限速所要的时间。默认为30 -Y/--speed-limit 停止传输速度的限制，速度时间'秒 -z/--time-cond 传送时间设置 -0/--http1.0 使用HTTP 1.0 -1/--tlsv1 使用TLSv1（SSL） -2/--sslv2 使用SSLv2的（SSL） -3/--sslv3 使用的SSLv3（SSL） --3p-quote like -Q for the source URL for 3rd party transfer --3p-url 使用url，进行第三方传送 --3p-user 使用用户名和密码，进行第三方传送 -4/--ipv4 使用IP4 -6/--ipv6 使用IP6 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"Linux/Mac-item2-crontab无法写入.html":{"url":"Linux/Mac-item2-crontab无法写入.html","title":"Mac-item2-crontab无法写入","keywords":"","body":"在item2中无法写入crontab 错误如图： 解决方法 If you allow iTerm Full Disk Access in System Preferences (System Preferences -> Security & Privacy -> Privacy -> Full Disk Access), you'll be able to edit your crontab. 其实就是修改电脑里安全设置里的完全磁盘访问权限 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"mobile/":{"url":"mobile/","title":"mobile","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"mobile/打包工程.html":{"url":"mobile/打包工程.html","title":"打包工程","keywords":"","body":"APP打包步骤 安装Android studio 及 gradle 下载Android studio 傻瓜安装 安装java8环境 安装gradle Gradle路径不对许使用绝对路径 如果遇到缺少sdk 27或28level环境的问题，需在Android studio里安装 配置java,gradle环境变量 PATH=\"/usr/local/opt/php@7.2/bin:$PATH\" export PATH=\"/usr/local/opt/php@7.2/sbin:$PATH\" export PATH=/Users/intech/gradle/gradle-4.6/bin:$PATH export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/ant/bin:/opt/reverse:$PATH export JAVA_HOME=$(/usr/libexec/java_home) export PATH=$JAVA_HOME/bin:$PATH export CLASS_PATH=$JAVA_HOME/lib 安装pop的iOS包管理 2019.01.03最新的CocoaPods安装教程 1、查看当前Ruby版本 ruby -v 2、更换源 sudo gem update --system gem sources --remove https://rubygems.org/ gem sources --add https://gems.ruby-china.com/ 3、为了验证你的Ruby镜像是并且仅是ruby-china，执行以下命令查看 gem sources -l *** CURRENT SOURCES *** https://gems.ruby-china.com/ 4、这时候才正式开始安装CocoaPods ```sh sudo gem install -n /usr/local/bin cocoapods ``` ​ 5、如果安装了多个Xcode使用下面的命令选择（一般需要选择最近的Xcode版本） ``` sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer ``` ​ 6、安装本地库 ```sh pod setup ``` 如果command line tools找不到，则进入xcode->perferece->locations->command line tools切换选项 证书：[安装p12文件 和 证书mobileprovision文件](https://blog.csdn.net/xxw888/article/details/73640139) ​ 另外还需要ExportOptions.plist拷贝到制定的项目下，其作用是配置工程的证书设置 ​ 如果遇到codesign的问题请检查证书559c1800-38ab-42f3-950c-ab545eeda3f2.mobileprovision go服务启动脚本 nohup ./httpfs -addr :port 如果遇到某些文件或文件夹生成后是read-only,需查看php的php-fpm是否启动，若启动看是否是root用户运行 如果遇到build时出现打包错误： tmp/cache, tmp/lock是否存在,并且具有写的权限 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"Nginx/":{"url":"Nginx/","title":"Nginx","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"Nginx/Mac开机自启动NGINX.html":{"url":"Nginx/Mac开机自启动NGINX.html","title":"Mac开机自启动NGINX","keywords":"","body":"Mac开机自启动NGINX和PHP Mac开机自启动NGINX和PHP 开机启动nginx: 在 /Library/LaunchDaemons/ 目录新建 org.macports.nginx.plist 文件: Label org.macports.nginx ProgramArguments /usr/local/bin/nginx KeepAlive 加载配置:launchctl load -w /Library/LaunchDaemons/org.macports.nginx.plist 开机启动php: 在 /Library/LaunchDaemons/ 目录新建 org.php.php-fpm.plist 文件: Label org.php.php-fpm ProgramArguments /usr/sbin/php-fpm KeepAlive 加载配置:launchctl load -w /Library/LaunchDaemons/org.php.php-fpm.plist Reference: launchd.plist-- System wide and per-user daemon/agent configuration files 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"Nginx/nginx编译安装参数.html":{"url":"Nginx/nginx编译安装参数.html","title":"nginx编译安装参数","keywords":"","body":"NGINX编译安装 --prefix=/usr/local/Cellar/nginx/1.15.8 --sbin-path=/usr/local/Cellar/nginx/1.15.8/bin/nginx --with-cc-opt='-I/usr/local/opt/pcre/include -I/usr/local/opt/openssl/include' --with-ld-opt='-L/usr/local/opt/pcre/lib -L/usr/local/opt/openssl/lib' --conf-path=/usr/local/etc/nginx/nginx.conf --pid-path=/usr/local/var/run/nginx.pid --lock-path=/usr/local/var/run/nginx.lock --http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp --http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp --http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp --http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp --http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp --http-log-path=/usr/local/var/log/nginx/access.log --error-log-path=/usr/local/var/log/nginx/error.log --with-debug --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-ipv6 --with-mail --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module 来brew install nginx的默认参数配置 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"npm/":{"url":"npm/","title":"npm","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"npm/install-npm-server.html":{"url":"npm/install-npm-server.html","title":"install-npm-server","keywords":"","body":"Link npm 私服工具verdaccio 搭建(一) | npm 私服工具verdaccio 搭建(二) | NodeJS学习：搭建私有NPM | pm2 status errored | 记录windows环境下用verdaccio搭建npm私有库 | gitlab之webhook自动部署 1.install node 下载最新的node环境，下载地址：https://nodejs.org/en/download/ #!/bin/bash wget https://nodejs.org/dist/v10.14.1/node-v10.14.1-linux-x64.tar.xz tar -zxvf node-v10.14.1-linux-x64 cp node-v10.14.1-linux-x64 /usr/local/node 2.安装verdaccio 加上–unsafe-perm的原因是防止报grywarn权限的错。 npm install -g verdaccio --unsafe-perm 3. 配置 3.1. 修改配置文件 verdaccio 的特点是，你在哪个目录运行，它的就会在对应的目录下创建自己的文件。目录下默认有两个文件：config.yaml和storage，htpasswd 是添加用户之后自动创建的； 由于第一次启动默认的config.xml文件是从原始文件default.yaml拷贝而来，可先修改verdaccio 原始的default.yaml。 地址：verdaccio 安装目录/conf/ default.yaml。 打开默认启动的config.yaml文件。 vim /home/admin/.config/verdaccio/config.yaml 在配置文件最后添加监听端口，配置文件详解请见文末尾 listen: 0.0.0.0:4873 # listen on all addresses 1 3.2. 对外开放4873端口 verdaccio继承了sinopia，端口号4873依然不变。 firewall-cmd --state # 先查看防火墙状态， service firewalld start # 开启防火墙: firewall-cmd --zone=public --add-port=4873/tcp –permanent #开放4873端口 firewall-cmd --reload #重新载入 firewall-cmd --zone=public --query-port=4873/tcp #查看是否添加成功 4.启动verdaccio 4.1.verdaccio直接启动 命令： verdaccio 1 // 显示信息， 第一句是配置文件的地址， 第二句，给了我们地址，访问便可以看到我们的私服已经搭建成功了。 目前还没有往上发布过包，所以没有任何包的信息。当我们打开页面还可以看到服务器这边有访问记录，控制台的日志一直在打。 verdaccio doesn‘t need superuser privileges. Don‘t run it und warn — config file - /home/admin/.config/verdaccio/config.yaml warn — http address - http://localhost:4873/ - verdaccio/ 4.2 pm2守护verdaccio进程 利用第一种方法虽然可以正常启动和使用verdaccio，但不建议用这种方式启动verdaccio，我们可以用pm2来使用pm2对verdaccio进程进行托管启动。 安装pm2并使用pm2启动verdaccio，使用pm2托管的进程可以保证进程永远是活着的，尝试通过kill -9去杀verdaccio的进程发现杀了之后又自动启起来。推荐使用此种方式启动verdaccio. 4.2.1安装pm2 npm install -g pm2 --unsafe-perm 1 4.2.2使用pm2启动verdaccio pm2 start verdaccio 1 4.2.3 查看pm2 守护下的进程verdaccio的实时日志 pm2 show verdaccio1 通过这个命令我们可以从下图中看到所有verdaccio的所有信息，打开 out log path查看进程输出日志,出现错误时候也可以打开error log来查看错误日志。 实时查看该路径下的日志命令： tail -f /home/admin/.pm2/logs/verdaccio-out-0.log1 添加用户 npm adduser --registry http://192.168.XX.XX:4873 //后面是我们的私服地址 类似如下： Username: lk Password: Email: (this IS public) lk@qq.com Logged in as rong on http://192.168.XX.XX:4873/. 然后在verdaccion启动页面尝试登录即可，默认登录后有发布包的权限。(这里可以通过修改config.yaml配置文件来对权限进行设置)、 到这里服务器端的搭建就完毕了，下篇我们来介绍客户端如何使用。 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"npm/npm-update.html":{"url":"npm/npm-update.html","title":"npm-update","keywords":"","body":"Npm使用npm-check选择升级所有可更新包(全局+局部) + 项目单个依 原文地址：https://blog.csdn.net/pcaxb/article/details/81773475 1.安装npm-check： （全局目录安装） npm install -g npm-check 2.npm 全局更新包 (全局目录) npm-check -u -g 通过上下键可以移动光标，使用空格键可以选择需要处理的包，回车直接进行处理。 3.npm更新某个项目的包 （项目目录） npm-check -u 通过上下键可以移动光标，使用空格键可以选择需要处理的包，回车直接进行处理。 通过npm-check -u 就可以，不需要--save就可以直接更新package.json里面的内容 4.npm 更新单个全局包 npm update -g 5.npm 更新 项目 生产环境依赖包 npm update --save 6.npm 更新 项目 开发环境依赖包 npm update --save-dev 7.npm 查找全局安装过的包 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"php/":{"url":"php/","title":"php","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"php/Mac编译安装phalcon.html":{"url":"php/Mac编译安装phalcon.html","title":"Mac编译安装phalcon","keywords":"","body":"linux下编译安装最新版phalcon centos下PHP7添加phalcon扩展 linux下编译安装phalcon 1、下载源码包 phalcon包 git clone --depth=1 git://github.com/phalcon/cphalcon.git ​ 进入目录 运行命令： cd build 执行安装文件 提示需要指定PHP的配置文件 运行命令： ./install --php-config /usr/local/php/bin/php-config --phpize /usr/local/php/bin/phpize 安装过程可能中断，提示需要re2c 然后去下载 运行命令： wget https://jaist.dl.sourceforge.net/project/re2c/old/re2c-0.13.4.tar.gz ​ brew install automake #安装aclocal命令 解压，编译安装。 然后重新再执行phalcon的 运行命令： ./install --php-config /usr/local/php/bin/php-config --phpize /usr/local/php/bin/phpize 编译完成之后，提示安装成功。 2、修改php.ini 添加phalcon.so扩展 运行命令： vi /usr/local/php/etc/php.ini 添加内容： extension=\"phalcon.so\" 然后保存，重启php。 3、测试是否安装成功 web目录里新建 test.php var_dump(get_loaded_extensions()); ?> 运行后看到有 phalcon扩展被加载， 即是安装phalcon框架成功。 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"php/php-fpm守护进程.html":{"url":"php/php-fpm守护进程.html","title":"php-fpm守护进程","keywords":"","body":"mac php-fpm 守护进程运行 问题是没有开启守护进程运行，php-fpm的时候出现 ready to handle connections … 关闭命令行窗口后又断开了 php-fpm ready to handle connections 解决方法： 1、首先要保证安装的PHP程序没有问题，因为我朋友启动php-fpm，网站的php文件依然可以解析，说明安装的程序没有任何问题。 2、查看php-fpm配置文件，因为php-fpm配置文件有一个选项是： daemonize = yes 后台执行fpm，默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。 vi /usr/local/etc/php/7.2/php-fpm.conf 这个是配置文件 但是我查看我朋友的php-fpm.conf配置文件，却发现它的“daemonize = no ”，因此只需要改过来就解决了！ 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"php/start-end.html":{"url":"php/start-end.html","title":"start-end","keywords":"","body":"PHP 获取今日、昨日、本周、上周、本月的等等常用的起始时间戳和结束时间戳的时间处理类 link:https://blog.csdn.net/mad_geek/article/details/72726086 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"python/":{"url":"python/","title":"python","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"python/pip set proxy.html":{"url":"python/pip set proxy.html","title":"pip set proxy","keywords":"","body":"让PIP源使用国内镜像，提升下载速度和安装成功率。 对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com //set trusted proxy host| --trusted-host windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"sass/":{"url":"sass/","title":"sass","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"sass/px-to-rem.html":{"url":"sass/px-to-rem.html","title":"px-to-rem","keywords":"","body":"Rem与Px的转换 https://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html $baseFontSizePx: 16px !default;//变量的值可以根据自己需求定义 @mixin remCalc($property, $values...) { $pxValues: ''; $remValues: ''; $baseFontSize: $baseFontSizePx / ($baseFontSizePx * 0 + 1); @each $value in $values { $pxValues: #{$pxValues + ' ' + $value * $baseFontSize}px; $remValues: #{$remValues + ' ' + $value}rem; } #{$property}: $pxValues; #{$property}: $remValues; } @mixin pxCalc($property, $values...) { $pxValues: ''; $remValues: ''; $baseFontSize: $baseFontSizePx / ($baseFontSizePx * 0 + 1); @each $value in $values { $pxValues: #{$pxValues + ' ' + $value}px; $remValues: #{$remValues + ' ' + $value / $baseFontSize}rem; } #{$property}: $pxValues; #{$property}: $remValues; } @function pxToRem($px){ @return $px / $baseFontSizePx * 1rem; } .wrapper { @include remCalc(width,32); @include remCalc(margin,16,8,32,64); @include remCalc(border,16); } .px { @include pxCalc(width,32); @include pxCalc(margin,16,8,32,64); @include pxCalc(border,16,solid,red); } 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"vim/":{"url":"vim/","title":"vim","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"vim/shortcut.html":{"url":"vim/shortcut.html","title":"shortcut","keywords":"","body":"vim 中批量添加注释 方法一 ：块选择模式 Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 // 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。 取消注释： Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 // 要选中两个，选好之后按 d 即可删除注释， ESC 保存退出。 方法二: 替换命令 批量注释。 使用下面命令在指定的行首添加注释。 使用名命令格式： :起始行号,结束行号s/^/注释符/g（注意冒号）。 取消注释： 使用名命令格式： :起始行号,结束行号s/^注释符//g（注意冒号）。 ​ 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"vim/study.html":{"url":"vim/study.html","title":"study","keywords":"","body":"Ubuntu uninstall sudo apt remove vim sudo apt autoremove install sudo apt install vim help manual Help -> :help -> :q/ZZ //打开帮助文档 Version: :version //查看版本 Download chinese language -> sourceforge search -> vim documentation chinese version -> download -> files ->vimcdoc -> select tar package -> download -> unpackage -> readme/INSTALL -> ./vimcdoc.sh -i/./vimcdoc.sh -u -> :set helplang=en/:set helplang=cn to change language version ctrl+] //跳转到当前光标所在单词的对应的主题 Ctrl+o 、、回到上一主题 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"webpack/":{"url":"webpack/","title":"webpack","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"webpack/file-handle.html":{"url":"webpack/file-handle.html","title":"file-handle","keywords":"","body":"webpack将资源打成zip包 该插件允许你复制，打包，移动，删除文件及文件夹在build之前及之后。 安装： ​ npm install filemanager-webpack-plugin --save-dev 资源打zip包 Webpack.config.js： const FileManagerPlugin = require('filemanager-webpack-plugin'); new FileManagerPlugin({ onEnd: { mkdir: ['./zip'], archive: [ { source: './dist', destination: './zip/test.zip' }, ] } }) 其他功能（移动，打包，复制）Webpack.config.js: const FileManagerPlugin = require('filemanager-webpack-plugin'); module.exports = { ... ... plugins: [ new FileManagerPlugin({ onEnd: { copy: [ { source: '/path/from', destination: '/path/to' }, { source: '/path/**/*.js', destination: '/path' }, { source: '/path/fromfile.txt', destination: '/path/tofile.txt' }, { source: '/path/**/*.{html,js}', destination: '/path/to' }, { source: '/path/{file1,file2}.js', destination: '/path/to' }, { source: '/path/file-[hash].js', destination: '/path/to' } ], move: [ { source: '/path/from', destination: '/path/to' }, { source: '/path/fromfile.txt', destination: '/path/tofile.txt' } ], delete: [ '/path/to/file.txt', '/path/to/directory/' ], mkdir: [ '/path/to/directory/', '/another/directory/' ], archive: [ { source: '/path/from', destination: '/path/to.zip' }, { source: '/path/**/*.js', destination: '/path/to.zip' }, { source: '/path/fromfile.txt', destination: '/path/to.zip' }, { source: '/path/fromfile.txt', destination: '/path/to.zip', format: 'tar' }, { source: '/path/fromfile.txt', destination: '/path/to.tar.gz', format: 'tar', options: { gzip: true, gzipOptions: { level: 1 } } } ] } }) ], ... } 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"友情链接/":{"url":"友情链接/","title":"友情链接","keywords":"","body":"让PIP源使用国内镜像，提升下载速度和安装成功率。 对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com // set https trusted host,--trusted-host windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"友情链接/blog.html":{"url":"友情链接/blog.html","title":"blog","keywords":"","body":"全栈博客 里边记录了Android，iOS，PHP，Git，Mac，Linux等等 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"友情链接/test.html":{"url":"友情链接/test.html","title":"test","keywords":"","body":" To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video 每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-24 10:52:06 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"每天记录一点点，每天提高一点点 all right reserved，powered by Gitbook该文件修订时间： 2019-01-21 08:56:44 "}}