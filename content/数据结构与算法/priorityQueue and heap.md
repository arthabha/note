# 优先队列(PriorityQueue)和堆(Heap)

#### 优先队列

普通队列: 先进先出;后进后出

优先队列:出队顺序和入队顺序无关;优先级高者早出队和优先级相关 （医院，患者优先级）

操作系统中任务的调度，动态选择优先级最高的任务执行。如果我们的任务不是动态，那么我们只需要一个排序算法就好了。

![img](https://img1.mukewang.com/5c127a040001d80907900498.jpg)

处理旧任务的同时也会有新任务不断的加入，因此此处的关键词**(动态)**

不能一开始确定有多少个任务，而是动态的不停有新元素入队，也有旧元素出队，因此我们要使用优先队列。

##### 优先队列的接口（本质依然是个队列）:

​	出队，入队，获取队首元素，获取队列大小，判断队列是否为空。

对于我们的优先队列来说，实现这些接口的时候，具体这些接口实现出来的功能会有区别。最大的区别在于出队和队首元素是谁这两个操作。此时出队元素应该是优先级最高的元素，队首的元素也是优先级最高的元素，而不是最早进入的那个。

可以使用不同的底层实现:

普通线性结构： 入队O(1)，查询比较优先级需要O(n) 。

顺序线性结构: 维持顺序O(n) 出队O(1)

![img](https://img.mukewang.com/5c127a050001421210130371.jpg)

堆的入队操作和出队操作都可以做到O(logn)级别。

![img](https://img.mukewang.com/5c127a050001cb0007770081.jpg)

### 堆的基础表示

通常见到O(logn)都与树有关，不一定是显式的构造了一棵树

堆本身也是一棵树，二叉堆(Binary Heap)

二叉堆是一棵完全二叉树。

- 满二叉树概念: 除了叶子节点，所有的节点的左右孩子都不为空，就是一棵满二叉树，如下图。

![img](https://img.mukewang.com/5c127a0500015e6809150391.jpg)

所有的节点都即拥有左孩子，又拥有右孩子，就是一棵满二叉树。

![img](https://img.mukewang.com/5c127a060001334809900523.jpg)

如上图是一棵完全二叉树，特点: 不一定是一个满二叉树，但它不满的那部分一定在右下侧。满二叉树中有多少层对应有多少节点变成了一个固定的事情。那我们要加入的节点并不是对应一整层，那么上一层满了，下一层从左到右依次排开。

最下面一层肯定都是叶子节点，上面一层即使有叶子节点，也一定分布在右侧。完全二叉树:把元素顺序按层排列成树的形状

#### 二叉堆的性质

堆中某个节点的值总是不大于其父节点的值。(所有节点的值都大于等于它的孩子节点的值)

![img](https://img3.mukewang.com/5c127a0600018d2111570533.jpg)

这样得到的是最大堆，相应的我们也可以定义出最小堆。某种程度上，最大堆和最小堆是可以统一的，因为什么是大，什么是小是我们可以定义的。

只保证自己的父亲节点比自己大，但是节点的层次和节点的大小之间是没有必然联系的。比如，第二层的13，层数比第三层的任何一个元素都小，但是值却并不小于。

因为完全二叉树，按顺序码放。

![img](https://img1.mukewang.com/5c127a060001b10e11680535.jpg)

我们就可以用过这样的一个数组来表示这个完全二叉树。数组存储节点i的左右孩子的规律。

```
parent(i) = i/2
left child(i) = 2*i;
right child(i) = 2*i+1;
```

可以使用数学归纳法来证明上面的关系对于完全二叉树是成立的。一般数组存储二叉堆由1开始，公式如上。如果从0开始，会有一个偏移。

```
parent(i) = (i-1)/2
left child(i) = 2*i+1;
right child(i) = 2*i+2;
```

![img](https://img1.mukewang.com/5c127a07000143eb07970437.jpg)

可以通过该图验证公式。

### 向堆中添加元素和Sift Up

从用户的角度是添加元素，从堆内部实现角度涉及堆中一个非常常见的操作 Sift Up.

堆中元素上浮的一个过程。

![img](http://myphoto.mtianyan.cn/20180814014648_k32MVZ_Screenshot.jpeg)

加入元素是非常简单的，直接添加进数组即可，但是可以看到，此时的树结构就不满足最大堆的要求: 父亲最大，16的儿子比16还大了。因此52要执行上浮操作。一个好好的堆怎么就出问题了呢？唯一的原因只会出现在52这个节点的新增，因此只需要将52不断的与它的父亲节点作比较，如果父亲小，就跟父亲互换，一直上浮互换，直到52不比自己的父亲大。

> 这里52 和 16 和 41 进行了两次互换操作。

### 取出堆中最大元素和Sift Down

最大堆只能取最大的那个元素，数组为0的位置，拿出去之后。将两棵子树合并的操作比较麻烦。

> 我们可以将最后一个元素填充到堆顶，然后不断的下沉这个元素。每次都与两个孩子进行比较，选择两个孩子中最大的那个元素，如果两个孩子中最大的那个元素比它自己还要大的话，那么它自己就和两个孩子中最大的那个交换位置。

### Heapify操作

heapify: 将任意数组整理成堆的形状

Heapify是倒着从最后一个元素的父亲节点开始倒着遍历进行siftdown操作。

#### Heapify的算法复杂度

将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn)

heapify的过程，算法复杂度为O(n)

